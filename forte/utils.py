"""
Util functions
"""
import contextlib
from pydoc import locate

__all__ = [
    "get_full_module_name",
    "get_class_name",
    "get_class",
    "get_qual_name",
    "shut_up",
]


def get_full_module_name(o, lower=False):
    """
    Returns the full module and class name of an object o.
    For example, for our :class: OntonotesReader, returns
    'nlp.forte.data.readers.ontonotes_reader.OntonotesReader'.
    """
    if not isinstance(o, type):
        o = o.__class__
    module = o.__module__
    if module is None or module == str.__class__.__module__:
        return o.__name__
    name = module + '.' + o.__name__
    if lower:
        return name.lower()
    else:
        return name


def get_class_name(o, lower=False):
    """
    Returns the class name of an object o.
    """
    if not isinstance(o, type):
        o = o.__class__
    if lower:
        return o.__name__.lower()
    else:
        return o.__name__


def get_class(class_name, module_paths=None):
    """Returns the class based on class name.

    Args:
        class_name (str): Name or full path to the class.
        module_paths (list): Paths to candidate modules to search for the
            class. This is used if the class cannot be located solely based on
            `class_name`. The first module in the list that contains the class
            is used.

    Returns:
        The target class.

    Raises:
        ValueError: If class is not found based on :attr:`class_name` and
            :attr:`module_paths`.
    """
    class_ = locate(class_name)
    if (class_ is None) and (module_paths is not None):
        for module_path in module_paths:
            class_ = locate('.'.join([module_path, class_name]))
            if class_ is not None:
                break

    if class_ is None:
        raise ValueError(
            "Class not found in {}: {}".format(module_paths, class_name))

    return class_


def get_qual_name(o, lower=False):
    """
    Returns the qualified name of an object o.
    """
    if not isinstance(o, type):
        o = o.__class__
    if lower:
        return o.__qualname__.lower()
    else:
        return o.__qualname__

@contextlib.contextmanager
def shut_up(stderr: bool = True, stdout: bool = False):
    r"""Suppress output (probably generated by external script or badly-written
    libraries) for stderr or stdout.

    This method can be used as a decorator, or a context manager:

    .. code-block: python

        @shut_up(stderr=True)
        def verbose_func(...):
            ...

        with shut_up(stderr=True):
            ... # verbose stuff

    :param stderr: If ``True``, suppress output from stderr.
    :param stdout: If ``True``, suppress output from stdout.
    """
    # redirect output to /dev/null
    fds = ([1] if stdout else []) + ([2] if stderr else [])
    null_fds = [os.open(os.devnull, os.O_RDWR) for _ in fds]
    output_fds = [os.dup(fd) for fd in fds]
    for null_fd, fd in zip(null_fds, fds):
        os.dup2(null_fd, fd)
    yield
    # restore normal stderr
    for null_fd, output_fd, fd in zip(null_fds, output_fds, fds):
        os.dup2(output_fd, fd)
        os.close(null_fd)
